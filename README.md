# 1 Identificação:
- Nome: Nicholas Zortea Graczik
- Curso: Paradigmas de Programação elc117

# 2 Tema / Objetivo:
Desenvolver uma aplicação utilizando o framework Scotty a qual realiza o envio do cardápio do RU (do dia seguinte) a uma lista de e-mails cadastrados.

# 3 Processo de desenvolvimento:
## Plano Inicial:
Em um primeiro momento pensei em pegar o cardápio do RU a partir de Web Scraping. Para isso precisaria realizar login no portal, ir até a página que mostra o cardápio e ler a partir do html o que seriam os itens de cada refeição, isso complicaria bastante a extração das informações, visto que precisaria me autenticar no portal, realizar requisições posteriores para chegar até o html desejado e montar uma lógica boa o bastante para extrair os dados. 

## Pensando melhor:
Graças a professora, a qual me avisou que existia uma rota que retornava o cardápio em json, as coisas foram simplificadas, principalmente por essa rota não precisar de autenticação. A partir dessa simplificação pude pensar em outros incrementos a adicionar no projeto. Por fim, idealizei que como objetivo final, gostaria de ser capaz de realizar um CRD (CRUD sem update kk) de e-mails, obter o cardápio do dia seguinte do RU e enviar para os e-mails "cadastrados" (leia-se inseridos dentro de um arquivo .txt). Para isso criei uma interface simples com html,css e javascript puro a qual permite cadastrar, deletar e enviar o cardápio. Como havia pensando em fazer esse envio automaticamente, criei um endpoint 'GET' no Scotty que realiza o envio para todos os e-mails cadastrados, dessa forma o usuário pode automatizar esse envio (através de um cronjob com uso do curl) e pode realizar manualmente a partir da interface.

## Primeiros Passos:
Como já havia pensando no que eu iria fazer como um todo, comecei pelas partes mais simples, criação de rotas para adicionar, deletar e retornar os e-mails cadastrados.

### CRUD dos e-mails:
Como forma de armazenar os e-mails pensei em utilizar um arquivo .txt principalmente pela simplicidade, portanto, existe um arquivo **"/src/data/emails.txt"** o qual possui um e-mail por linha. Para realizar a adição de e-mails criei a rota 'POST' "/addEmail/:e" a qual recebe o e-mail como parâmetro pela URL, não é a melhor prática mas a mais simples, uma rota 'DELETE' "/deleteEmail/:e" que realiza a exclusão do e-mail recebido como parâmetro. Tanto o "addEmail" como o "deleteEmail" realizam uma verificação básica, no add é verificado se o e-mail já existe no arquivo "emails.txt" se sim retorna o código 409 e informa que o e-mail já está cadastrado, no delete é verificado se o e-mail existe, se não existe retorna 409 e informa que o e-mail não existe. Por fim também criei uma rota 'GET' "/getEmails" que retorna todos os e-mails cadastrados como uma string no formato: ["e-mail1", "e-mail2", "e-mail3"]. Até esse momento as fontes que havia consultado haviam suprido a minha necessidade (https://stackoverflow.com/questions/7867723/haskell-file-reading, https://livebook.manning.com/book/get-programming-with-haskell/chapter-24/).

### Enviando e-mails:
Com o "CRUD" dos e-mails finalizado decidi focar meus esforços no envio dos e-mails, a partir de então as coisas começaram a ficar mais nebulosas, as soluções não eram mais tão óbvias, eu já não encontrava mais as respostas para os problemas que apareciam, muito menos a documentação para poder entender como fazer, ao mesmo tempo em que o ChatGPT gerava código corrigindo os erros eram introduzidos mais 20 no lugar, tudo em um ciclo sem fim. Para conseguir entender o que precisava fazer, como fazer e como corrigir o que estava dando de errado, precisei olhar as definições do Network.Mail.Mime (https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/Network-Mail-Mime.html, https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/src/Network-Mail-Mime.html#Mail) do Network.HaskellNet.SMTP (https://hackage.haskell.org/package/HaskellNet-0.6.1.2/docs/Network-HaskellNet-SMTP.html) e esse trecho de código (https://gist.github.com/Jim-Holmstroem/50f471351e6cd5bbed82d35324d09a48). Além disso como criei uma conta no gmail para realizar o envio dos e-mails, precisei habilitar autenticação de dois fatores e criar uma senha específica para a conta utilizar nesse projeto (https://support.google.com/accounts/answer/185833?hl=pt-BR). Como gostaria de deixar essa conta e senha seguras e possibilitar que qualquer conta (desde que seja do gmail) possa ser usado para realizar o envio dos e-mails. Criei um arquivo txt em **"/src/data/sender.txt"**, o qual contém o email e a senha para enviar e-mails no formato <br/>
email:qualquer@gmail.com<br/>
pass:senha<br/>
Aproveitei algumas funções do CRUD de e-mails para isso e criei outras para tratar essas informações como uma lista de tuplas de String, no formato [(propriedade, valor)]. Além disso também tive problemas com as portas 465 e 587 (de envio de e-mail) no meu computador e precisei usar o UFW(Uncomplicated Firewall) para permitir o tráfego nessas portas, possibilitando o envio dos e-mails.

## Interface
Com os itens anteriores prontos, já havia bastante material substancial de backend. Faltava algo mais interativo, já estava cansado de usar o Postman para adicionar e deletar os e-mails. Portanto decidi criar um html que renderizava os e-mails cadastrados "dinamicamente", para isso criei o arquivo **Pages.hs** que contém a página principal escrita como uma string repleta de concatenações, a lista de e-mails consiste em um map que concatena elementos html "li" em e-mails provenientes de uma lista. Depois disso, foi necessário adicionar um campo e botões de adicionar e deletar e-mails. Para isso, criei o form html e os arquivos **style.css** e **script.js** este o responsável por realizar as requisições de adição e deleção de e-mails a partir dos botões e do campo que deve ser preenchido. Com esses dois novos arquivos, precisei criar duas novas rotas: 'GET' "/css" e 'GET' "/javascript" a quais retornam os arquivos mencionandos anteriormente para que o navegador possa utilizá-los. Também criei a rota principal 'GET' "/" que rendiza o html mencionado. <br/> Aqui as fontes utilizadas foram mais relacionadas a html,css e javascript (https://www.w3schools.com/js/js_validation.asp, https://www.w3schools.com/html/html_forms.asp) e utilizei o ChatGPT como forma de tirar dúvidas sobre como seria a arquitetura com esses arquivos, principalmente em como fornecer eles para o navegador.

## Cardápio
As coisas aqui ficaram um pouco confusas, vamos com calma:

### Arquivo Refeicoes.hs
Esse arquivo implementa um novo record "Refeicao" a qual contém os dois únicos campos que me interessam do json que é fornecido pela rota da UFSM, **"descricao"** e **"title"** os quais respectivamente contém uma string separada pelo elemento html br com todos os itens do cardapio e o outro que contém o título da refeição("Café", "Almoço", "Jantar") a qual a descrição pertence. Nesse arquivo eu faço o uso da lib Aeson a qual faz a desserialização do Json para esse record Refeicao, facilitando o manuseio das informações. <br/>
Neste arquivo existe a função que recebe o caminho do json e retorna uma lista de Refeição, a qual eu uso para montar o html da página principal e para enviar o e-mail. Em um primeiro momento pensei em utilizar o br para separar a descricao em uma lista de itens do cardápio, mas como posteriormente eu preciso montar um html com essa lista, optei por criar uma função que converte uma Refeicao para uma tupla no formato **(titulo, descricao)**.

### rota 'GET' "/":
Quando essa rota é requisita, ela chama a função **saveCardapio** que faz a requisição a UFSM que obtém o cardápio do dia seguinte o qual é salvo no arquivo **"cardapio.json"**. Portanto é fundamental que essa rota seja requisitada para que o cardapio seja atualizado antes de enviar os e-mails (se feito de forma automática).

### requisição a UFSM:
A requisição que retorna o JSON com os cardápios é dada pela URL:https://portal.ufsm.br/ru/publico/buscarCardapio.json?inicio=1727568000&fim=1731196800&idRestaurante=1&tiposRefeicao[]=1&tiposRefeicao[]=2&tiposRefeicao[]=3 <br/>
onde os parametros **inicio** e **fim** recebem um timestamp que representa o intervalo de interesse dos cardapios. Essa informação é muito importante, pois cada refeicao possui um timestamp também, tendo como base sempre **12:00 AM**. Portanto se desejo o cardapio do dia seguinte contendo o café, almoço e jantar. no parâmetro inicio e fim da URL supracitada **deve constar o timestamp do dia seguinte as 12:00 AM**. Essa lógica é utilizada na hora de realizar a requisição à UFSM.<br/>
Aqui as fontes consultadas foram:https://stackoverflow.com/questions/12406311/haskell-aeson-how-to-debug-instances, https://hackage.haskell.org/package/aeson, https://tech.fpcomplete.com/haskell/library/aeson/, https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json

# 4 Resultado final:
[!Video demonstracao](video_demonstracao.webm)

# 5 Referencias e créditos:
https://stackoverflow.com/questions/12406311/haskell-aeson-how-to-debug-instances, https://hackage.haskell.org/package/aeson, https://tech.fpcomplete.com/haskell/library/aeson/, https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json, https://www.w3schools.com/js/js_validation.asp, https://www.w3schools.com/html/html_forms.asp, https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/Network-Mail-Mime.html, https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/src/Network-Mail-Mime.html#Mail, https://hackage.haskell.org/package/HaskellNet-0.6.1.2/docs/Network-HaskellNet-SMTP.html, https://gist.github.com/Jim-Holmstroem/50f471351e6cd5bbed82d35324d09a48, https://stackoverflow.com/questions/7867723/haskell-file-reading, https://livebook.manning.com/book/get-programming-with-haskell/chapter-24/ <br/>
Eu utilizei Prompts principalmente para resolução de erros, colando o código e o erro, mas isso acabava me gerando código com um erro diferente...