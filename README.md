# 1 Identificação:
- Nome: Nicholas Zortea Graczik
- Curso: Paradigmas de Programação elc117

# 2 Tema / Objetivo:
Desenvolver uma aplicação utilizando o framework Scotty a qual realiza o envio do cardápio do RU (do dia seguinte) a uma lista de e-mails cadastrados.

# 3 Processo de desenvolvimento:
## Plano Inicial:
Em um primeiro momento pensei em pegar o cardápio do RU a partir de Web Scraping. Para isso precisaria realizar login no portal, ir até a página que mostra o cardápio e ler a partir do html o que seriam os itens de cada refeição, isso complicaria bastante a extração das informações, visto que precisaria me autenticar no portal, realizar requisições posteriores para chegar até o html desejado e montar uma lógica boa o bastante para extrair os dados. 

## Pensando melhor:
Graças a professora, a qual me avisou que existia uma rota que retornava o cardápio em json, as coisas foram simplificadas, principalmente por essa rota não precisar de autenticação. A partir dessa simplificação pude pensar em outros incrementos a adicionar no projeto. Por fim, idealizei que como objetivo final, gostaria de ser capaz de realizar um CRD (CRUD sem update kk) de e-mails, obter o cardápio do dia seguinte do RU e enviar para os e-mails "cadastrados" (leia-se inseridos dentro de um arquivo .txt). Para isso criei uma interface simples com html,css e javascript puro a qual permite cadastrar, deletar e enviar o cardápio. Como havia pensando em fazer esse envio automaticamente, criei um endpoint 'GET' no Scotty que realiza o envio para todos os e-mails cadastrados, dessa forma o usuário pode automatizar esse envio (através de um cronjob com uso do curl) e pode realizar manualmente a partir da interface.

## Primeiros Passos:
Como já havia pensando no que eu iria fazer como um todo, comecei pelas partes mais simples, criação de rotas para adicionar, deletar e retornar os e-mails cadastrados.

### CRUD dos e-mails:
Como forma de armazenar os e-mails pensei em utilizar um arquivo .txt principalmente pela simplicidade, portanto, existe um arquivo **"/src/data/emails.txt"** o qual possui um e-mail por linha. Para realizar a adição de e-mails criei a rota 'POST' "/addEmail/:e" a qual recebe o e-mail como parâmetro pela URL, não é a melhor prática mas a mais simples, uma rota 'DELETE' "/deleteEmail/:e" que realiza a exclusão do e-mail recebido como parâmetro. Tanto o "addEmail" como o "deleteEmail" realizam uma verificação básica, no add é verificado se o e-mail já existe no arquivo "emails.txt" se sim retorna o código 409 e informa que o e-mail já está cadastrado, no delete é verificado se o e-mail existe, se não existe retorna 409 e informa que o e-mail não existe. Por fim também criei uma rota 'GET' "/getEmails" que retorna todos os e-mails cadastrados como uma string no formato: ["e-mail1", "e-mail2", "e-mail3"]. Até esse momento as fontes que havia consultado haviam suprido a minha necessidade (https://stackoverflow.com/questions/7867723/haskell-file-reading, https://livebook.manning.com/book/get-programming-with-haskell/chapter-24/).

### Enviando e-mails:
Com o "CRUD" dos e-mails finalizado decidi focar meus esforços no envio dos e-mails, a partir de então as coisas começaram a ficar mais nebulosas, as soluções não eram mais tão óbvias, eu já não encontrava mais as respostas para os problemas que apareciam, muito menos a documentação para poder entender como fazer, ao mesmo tempo em que o ChatGPT gerava código corrigindo os erros eram introduzidos mais 20 no lugar, tudo em um ciclo sem fim. Para conseguir entender o que precisava fazer, como fazer e como corrigir o que estava dando de errado, precisei olhar as definições do Network.Mail.Mime (https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/Network-Mail-Mime.html, https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/src/Network-Mail-Mime.html#Mail) do Network.HaskellNet.SMTP (https://hackage.haskell.org/package/HaskellNet-0.6.1.2/docs/Network-HaskellNet-SMTP.html) e esse trecho de código (https://gist.github.com/Jim-Holmstroem/50f471351e6cd5bbed82d35324d09a48). Além disso como criei uma conta no gmail para realizar o envio dos e-mails, precisei habilitar autenticação de dois fatores e criar uma senha específica para a conta utilizar nesse projeto (https://support.google.com/accounts/answer/185833?hl=pt-BR). Como gostaria de deixar essa conta e senha seguras e possibilitar que qualquer conta (desde que seja do gmail) possa ser usado para realizar o envio dos e-mails. Criei um arquivo txt em **"/src/data/sender.txt"**, o qual contém o email e a senha para enviar e-mails no formato <br/>
email:qualquer@gmail.com<br/>
pass:senha<br/>
Aproveitei algumas funções do CRUD de e-mails para isso e criei outras para tratar essas informações como uma lista de tuplas de String, no formato [(propriedade, valor)]. Além disso também tive problemas com as portas 465 e 587 (de envio de e-mail) no meu computador e precisei usar o UFW(Uncomplicated Firewall) para permitir o tráfego nessas portas, possibilitando o envio dos e-mails.

## Interface
Com os itens anteriores prontos, já havia bastante material substancial de backend. Faltava algo mais interativo, já estava cansado de usar o Postman para adicionar e deletar os e-mails. Portanto decidi criar um html que renderizava os e-mails cadastrados "dinamicamente", para isso criei o arquivo **Pages.hs** que contém a página principal escrita como uma string repleta de concatenações, a lista de e-mails consiste em um map que concatena elementos html "li" em e-mails provenientes de uma lista. Depois disso, foi necessário adicionar um campo e botões de adicionar e deletar e-mails. Para isso, criei o form html e os arquivos **style.css** e **script.js** este o responsável por realizar as requisições de adição e deleção de e-mails a partir dos botões e do campo que deve ser preenchido. Com esses dois novos arquivos, precisei criar duas novas rotas: 'GET' "/css" e 'GET' "/javascript" a quais retornam os arquivos mencionandos anteriormente para que o navegador possa utilizá-los. Aqui as fontes utilizadas foram mais relacionadas a html,css e javascript (https://www.w3schools.com/js/js_validation.asp, https://www.w3schools.com/html/html_forms.asp)